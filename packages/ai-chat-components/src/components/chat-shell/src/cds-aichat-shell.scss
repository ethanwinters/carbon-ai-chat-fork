/**
 * @license
 *
 * Copyright IBM Corp. 2025
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

@use "@carbon/layout";
@use "@carbon/styles/scss/theme";
@use "@carbon/styles/scss/motion";
@use "../../../globals/scss/vars" as *;

$messages-max-width: var(--cds-aichat-messages-max-width, 672px);
$messages-min-width: var(--cds-aichat-messages-min-width, 320px);
$workspace-min-width: var(--cds-aichat-workspace-min-width, 640px);
$history-width: var(--cds-aichat-history-width, 320px);

$ai-background-image: linear-gradient(
  to bottom,
  #{theme.$chat-shell-background} 0,
  #{theme.$chat-shell-background} 50%,
  #{theme.$ai-aura-end} 50%,
  #{theme.$ai-aura-start} 100%
);
$ai-box-shadow-outer: 0 4px 10px 2px #{theme.$ai-drop-shadow};
$default-box-shadow: 1px 0 4px hsl(0deg 0% 9% / 30%);

:host {
  display: block;
  box-sizing: border-box;
  background: transparent;
  block-size: 100%;
  container-type: inline-size;
  inline-size: 100%;
}

.shell {
  --#{$prefix}-rounded-radius: 0;
  --#{$prefix}-rounded-radius-start-start: 0;
  --#{$prefix}-rounded-radius-start-end: 0;
  --#{$prefix}-rounded-radius-end-start: 0;
  --#{$prefix}-rounded-radius-end-end: 0;

  position: relative;
  display: block;
  border: 1px solid theme.$border-subtle-00;
  border-radius: var(--#{$prefix}-rounded-radius, 0);
  background-color: theme.$chat-shell-background;
  background-image: none;
  block-size: 100%;
  box-shadow: var(--cds-aichat-box-shadow, $default-box-shadow);
  inline-size: 100%;
}

[data-panel-slot] {
  opacity: 1;
}

[data-panel-slot][inert] {
  opacity: 0;
}

@media screen and (prefers-reduced-motion: no-preference) {
  [data-panel-slot] {
    transition: opacity motion.$duration-fast-02
      motion.motion(standard, productive);
  }
}

.shell.shell--panels-animating {
  overflow: hidden;
}

// Base .main-content-body must come before more specific selectors
.main-content-body {
  position: relative;
  display: flex;
  flex: 1 1 0%;
  align-items: stretch;
  block-size: 100%;
  max-inline-size: 100%;
  min-block-size: inherit;
  min-inline-size: 0;
  overflow-x: visible;
}

.shell.workspace-closing,
.shell.workspace-opening {
  .main-content-body {
    overflow-x: hidden;
  }
}

// Base .main-chat must come before more specific selectors
.main-chat {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  block-size: 100%;
  inline-size: 100%;
}

.shell.ai-theme {
  border: 1px solid transparent;
  background: linear-gradient(
      to bottom,
      theme.$ai-border-start,
      theme.$ai-border-end
    )
    border-box;
  background-color: theme.$chat-shell-background;
  box-shadow: $ai-box-shadow-outer;

  .main-chat {
    background-color: theme.$chat-shell-background;
    background-image: $ai-background-image;
  }
}

.shell.frameless,
.shell.frameless.rounded {
  --#{$prefix}-rounded-radius: 0;
  --#{$prefix}-rounded-radius-start-start: 0;
  --#{$prefix}-rounded-radius-start-end: 0;
  --#{$prefix}-rounded-radius-end-start: 0;
  --#{$prefix}-rounded-radius-end-end: 0;

  border: none;
  border-radius: var(--#{$prefix}-rounded-radius, 0);
  box-shadow: none;
}

.shell.rounded {
  // Set the base rounded radius custom property that can be inherited by slotted content
  --#{$prefix}-rounded-radius: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-start-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-start-end: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-end-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-end-end: #{layout.$spacing-03};

  border-radius: var(--#{$prefix}-rounded-radius, 0);

  .main-chat {
    border-radius: var(--#{$prefix}-rounded-radius, 0);
  }

  .header-with-header-after {
    border-start-end-radius: var(--#{$prefix}-rounded-radius-start-end, 0);
    border-start-start-radius: var(--#{$prefix}-rounded-radius-start-start, 0);

    // Apply rounded corners to header when it has content
    > .header.has-content {
      border-start-end-radius: var(--#{$prefix}-rounded-radius-start-end, 0);
      border-start-start-radius: var(
        --#{$prefix}-rounded-radius-start-start,
        0
      );
    }

    // Apply rounded corners to header-after only when header is empty but header-after has content
    > .header:not(.has-content) + .header-after.has-content {
      border-start-end-radius: var(--#{$prefix}-rounded-radius-start-end, 0);
      border-start-start-radius: var(
        --#{$prefix}-rounded-radius-start-start,
        0
      );
    }

    // Reset rounded corners for header when it has no content
    > .header:not(.has-content) {
      --#{$prefix}-rounded-radius-start-end: 0;
      --#{$prefix}-rounded-radius-start-start: 0;

      border-start-end-radius: 0;
      border-start-start-radius: 0;
    }

    // Reset rounded corners for header-after when it has no content
    > .header-after:not(.has-content) {
      --#{$prefix}-rounded-radius-start-end: 0;
      --#{$prefix}-rounded-radius-start-start: 0;

      border-start-end-radius: 0;
      border-start-start-radius: 0;
    }

    // Reset rounded corners for header-after when header has content (header takes priority)
    > .header.has-content + .header-after {
      --#{$prefix}-rounded-radius-start-end: 0;
      --#{$prefix}-rounded-radius-start-start: 0;

      border-start-end-radius: 0;
      border-start-start-radius: 0;
    }
  }
}

.main-content {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  align-items: stretch;
  max-inline-size: 100%;
  min-inline-size: 0;
}

:host([show-workspace]) .main-content-body,
.shell.workspace-closing .main-content-body,
.shell.workspace-opening .main-content-body {
  flex-direction: row;
  container-name: main-content-body;
  container-type: inline-size;
}

:host([workspace-in-panel]) .main-content-body {
  flex-direction: column;
}

.input-and-messages {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  align-items: stretch;
  margin: auto;
  block-size: 100%;
  inline-size: 100%;
  max-inline-size: $messages-max-width;
  min-inline-size: $messages-min-width;
}

:host([show-workspace]) .input-and-messages,
.shell.workspace-closing .input-and-messages,
.shell.workspace-opening .input-and-messages {
  flex: 0 0 $messages-min-width;
  inline-size: $messages-min-width;
  max-inline-size: $messages-min-width;
}

:host([workspace-in-panel][show-workspace]) .input-and-messages {
  flex: 1 1 auto;
  inline-size: 100%;
  max-inline-size: $messages-max-width;
}

.workspace {
  display: flex;
  flex-direction: column;
}

// Base selectors must come before more specific ones
:host([show-workspace]) .workspace {
  flex: 1 1 auto;
  min-inline-size: $workspace-min-width;
}

.shell.workspace-closing .workspace,
.shell.workspace-opening .workspace {
  flex: 1 1 auto;
  min-inline-size: 0;
}

:host(:not([workspace-in-panel])[show-workspace]) {
  .workspace,
  .input-and-messages {
    box-sizing: border-box;
    padding-block-end: layout.$spacing-05;
    padding-block-start: layout.$spacing-05;
    padding-inline-end: layout.$spacing-05;
    padding-inline-start: layout.$spacing-05;
  }

  .workspace {
    padding-inline-end: 0;
  }
}

:host([show-workspace][workspace-location="end"]) .workspace,
:host([workspace-location="end"]) .shell.workspace-closing .workspace,
:host([workspace-location="end"]) .shell.workspace-opening .workspace {
  order: 2;
}

.history {
  display: flex;
  flex-direction: column;

  > [data-panel-slot] {
    display: flex;
    flex: 1;
    flex-direction: column;
    block-size: 100%;
    min-block-size: 0;
  }
}

:host([show-history]) .history {
  flex: 0 0 auto;
  inline-size: $history-width;
  max-inline-size: $history-width;
}

// When header or header-after has content, reset top corners for input-and-messages
// This prevents slotted content from incorrectly applying rounded corners
.shell.rounded.has-header-content .input-and-messages {
  --#{$prefix}-rounded-radius-start-start: 0;
  --#{$prefix}-rounded-radius-start-end: 0;
}

// When NOT at max width (>672px), reset top and bottom corners on input-and-messages
// This prevents messages-before from getting rounded corners when centered
// and prevents centered content from getting rounded corners
.shell.rounded .input-and-messages:not(.at-max-width) {
  --#{$prefix}-rounded-radius-start-start: 0;
  --#{$prefix}-rounded-radius-start-end: 0;
  --#{$prefix}-rounded-radius-end-start: 0;
  --#{$prefix}-rounded-radius-end-end: 0;
}

// When footer has content, reset bottom corners for input-and-messages
// This prevents slotted content from incorrectly applying rounded corners
.shell.rounded.has-footer-content .input-and-messages {
  --#{$prefix}-rounded-radius-end-start: 0;
  --#{$prefix}-rounded-radius-end-end: 0;
}

:host([show-history][history-location="end"]) .input-and-messages {
  order: 1;
}

:host([show-workspace][workspace-location="end"]) .input-and-messages,
:host([workspace-location="end"]) .shell.workspace-closing .input-and-messages,
:host([workspace-location="end"]) .shell.workspace-opening .input-and-messages {
  order: 1;
}

:host([show-history][history-location="end"]) .history {
  order: 3;
}

:host([show-history][show-workspace][workspace-location="end"]) .workspace {
  order: 2;
}

:host(:not([workspace-in-panel])[show-workspace][workspace-location="end"]) {
  .workspace {
    padding-inline-end: layout.$spacing-05;
  }

  .input-and-messages {
    padding-inline-end: 0;
  }
}

/* Make sure input field gets pushed to the bottom */
.messages {
  flex-grow: 1;
}

// When input-and-messages is at max width but NO header content, keep the rounded corners
// (they will be inherited by messages-before or messages)
.shell.rounded:not(.has-header-content) .input-and-messages.at-max-width {
  --#{$prefix}-rounded-radius-start-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-start-end: #{layout.$spacing-03};
}

// When messages-before has content, messages doesn't need top rounded corners
.shell.rounded .input-and-messages.has-messages-before-content > .messages {
  --#{$prefix}-rounded-radius-start-start: 0;
  --#{$prefix}-rounded-radius-start-end: 0;
}

// Main content area gets bottom corners by default
.shell.rounded .main-content {
  border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
  border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);

  // Footer has priority - gets bottom corners when it has content
  > .footer.has-content {
    border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
    border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
  }

  // Reset footer corners when no content
  > .footer:not(.has-content) {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// When input-and-messages is at max width but NO footer content, keep the rounded corners
// (they will be inherited by input-after, input, input-before, messages-after, or messages)
.shell.rounded:not(.has-footer-content) .input-and-messages.at-max-width {
  --#{$prefix}-rounded-radius-end-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-radius-end-end: #{layout.$spacing-03};
}

// Reset corners for slots that don't have content (must come before positive rules)
.shell.rounded .input-and-messages {
  > .input-after:not(.has-content),
  > .input:not(.has-content),
  > .input-before:not(.has-content),
  > .messages-after:not(.has-content) {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }

  // 5. messages (FALLBACK) gets bottom corners when all other bottom slots are empty
  // This must come BEFORE the reset rules to maintain proper specificity
  &:not(
      .has-input-after-content,
      .has-input-content,
      .has-input-before-content,
      .has-messages-after-content
    )
    > .messages {
    border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
    border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
  }

  // Reset corners for messages in various contexts (must come after the fallback rule)
  // When input-after has content, reset corners for all slots below it
  &.has-input-after-content > .messages,
  // When input has content (and input-after is empty), reset corners for slots below it
  &:not(.has-input-after-content).has-input-content > .messages,
  // When input-before has content (and input-after/input are empty), reset corners for slots below it
  &:not(.has-input-after-content, .has-input-content).has-input-before-content > .messages {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// Priority cascade for bottom slots within input-and-messages
// 1. input-after has highest priority
.shell.rounded .input-and-messages > .input-after.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
  border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
}

// 2. input gets corners only if input-after is empty
.shell.rounded
  .input-and-messages:not(.has-input-after-content)
  > .input.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
  border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
}

// 3. input-before gets corners only if input-after and input are empty
.shell.rounded
  .input-and-messages:not(.has-input-after-content, .has-input-content)
  > .input-before.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
  border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
}

// 4. messages-after gets corners only if all input slots are empty
.shell.rounded
  .input-and-messages:not(
    .has-input-after-content,
    .has-input-content,
    .has-input-before-content
  )
  > .messages-after.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-radius-end-end, 0);
  border-end-start-radius: var(--#{$prefix}-rounded-radius-end-start, 0);
}

// When input-after has content, reset corners for all slots below it
.shell.rounded .input-and-messages.has-input-after-content {
  > .input,
  > .input-before,
  > .messages-after {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// When input has content (and input-after is empty), reset corners for slots below it
.shell.rounded
  .input-and-messages:not(.has-input-after-content).has-input-content {
  > .input-before,
  > .messages-after {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// When input-before has content (and input-after/input are empty), reset corners for slots below it
.shell.rounded
  .input-and-messages:not(
    .has-input-after-content,
    .has-input-content
  ).has-input-before-content {
  > .messages-after {
    --#{$prefix}-rounded-radius-end-start: 0;
    --#{$prefix}-rounded-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// When messages-after has content (and all input slots are empty), reset corners for messages
.shell.rounded
  .input-and-messages:not(
    .has-input-after-content,
    .has-input-content,
    .has-input-before-content
  ).has-messages-after-content
  > .messages {
  --#{$prefix}-rounded-radius-end-start: 0;
  --#{$prefix}-rounded-radius-end-end: 0;

  border-end-end-radius: 0;
  border-end-start-radius: 0;
}

.workspace-slot {
  block-size: 100%;
  inline-size: 100%;
}

.workspace-content {
  block-size: 100%;
  inline-size: 100%;
  opacity: 1;
}

@media (prefers-reduced-motion: no-preference) {
  .workspace-content {
    transition: opacity motion.$duration-fast-02
      motion.motion(standard, productive);
  }
}

.workspace-content--hidden {
  opacity: 0;
  pointer-events: none;
}
