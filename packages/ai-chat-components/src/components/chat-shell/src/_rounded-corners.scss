/**
 * @license
 *
 * Copyright IBM Corp. 2025
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

@use "@carbon/layout";
@use "../../../globals/scss/vars" as *;

// ============================================================================
// Rounded Corners - Main Content
// ============================================================================

// Main content area gets bottom corners by default
.shell.rounded .main-content {
  border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
  border-end-start-radius: var(
    --#{$prefix}-rounded-modifier-radius-end-start,
    0
  );

  // Footer has priority - gets bottom corners when it has content
  > .footer.has-content {
    --#{$prefix}-rounded-modifier-radius-start-start: 0;
    --#{$prefix}-rounded-modifier-radius-start-end: 0;

    border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
    border-end-start-radius: var(
      --#{$prefix}-rounded-modifier-radius-end-start,
      0
    );
  }

  // Reset footer corners when no content
  > .footer:not(.has-content) {
    --#{$prefix}-rounded-modifier-radius-end-start: 0;
    --#{$prefix}-rounded-modifier-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// ============================================================================
// Rounded Corners - Input and Messages
// ============================================================================

// When header or header-after has content, reset top corners for input-and-messages
// This prevents slotted content from incorrectly applying rounded corners
.shell.rounded.has-header-content .input-and-messages {
  --#{$prefix}-rounded-modifier-radius-start-start: 0;
  --#{$prefix}-rounded-modifier-radius-start-end: 0;
}

// When NOT at max width (>672px), reset top and bottom corners on input-and-messages
// This prevents centered content from getting rounded corners
.shell.rounded .input-and-messages:not(.at-max-width) {
  --#{$prefix}-rounded-modifier-radius-start-start: 0;
  --#{$prefix}-rounded-modifier-radius-start-end: 0;
  --#{$prefix}-rounded-modifier-radius-end-start: 0;
  --#{$prefix}-rounded-modifier-radius-end-end: 0;
}

// When footer has content, reset bottom corners for input-and-messages
// This prevents slotted content from incorrectly applying rounded corners
.shell.rounded.has-footer-content .input-and-messages {
  --#{$prefix}-rounded-modifier-radius-end-start: 0;
  --#{$prefix}-rounded-modifier-radius-end-end: 0;
}

// When input-and-messages is at max width but NO header content, keep the rounded corners
// (they will be inherited by messages)
.shell.rounded:not(.has-header-content) .input-and-messages.at-max-width {
  --#{$prefix}-rounded-modifier-radius-start-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-modifier-radius-start-end: #{layout.$spacing-03};
}

// When input-and-messages is at max width but NO footer content, keep the rounded corners
// (they will be inherited by input-after, input, input-before, or messages)
.shell.rounded:not(.has-footer-content) .input-and-messages.at-max-width {
  --#{$prefix}-rounded-modifier-radius-end-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-modifier-radius-end-end: #{layout.$spacing-03};
}

// ============================================================================
// Rounded Corners - Bottom Slot Priority Cascade
// ============================================================================

// Reset corners for slots that don't have content (must come before positive rules)
.shell.rounded .input-and-messages {
  > .input-after:not(.has-content),
  > .input:not(.has-content),
  > .input-before:not(.has-content) {
    --#{$prefix}-rounded-modifier-radius-end-start: 0;
    --#{$prefix}-rounded-modifier-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }

  // 4. messages (FALLBACK) gets bottom corners when all input slots are empty
  // This must come BEFORE the reset rules to maintain proper specificity
  &:not(.has-input-after-content, .has-input-content, .has-input-before-content)
    > .messages {
    border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
    border-end-start-radius: var(
      --#{$prefix}-rounded-modifier-radius-end-start,
      0
    );
  }

  // Reset corners for messages in various contexts (must come after the fallback rule)
  // When input-after has content, reset corners for all slots below it
  &.has-input-after-content > .messages,
  // When input has content (and input-after is empty), reset corners for slots below it
  &:not(.has-input-after-content).has-input-content > .messages,
  // When input-before has content (and input-after/input are empty), reset corners for slots below it
  &:not(.has-input-after-content, .has-input-content).has-input-before-content > .messages {
    --#{$prefix}-rounded-modifier-radius-end-start: 0;
    --#{$prefix}-rounded-modifier-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// Priority cascade for bottom slots within input-and-messages
// 1. input-after has highest priority
.shell.rounded .input-and-messages > .input-after.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
  border-end-start-radius: var(
    --#{$prefix}-rounded-modifier-radius-end-start,
    0
  );
}

// Explicitly set custom properties on input-after when at max width and no footer
// so slotted content can read them
.shell.rounded:not(.has-footer-content)
  .input-and-messages.at-max-width
  > .input-after.has-content {
  --#{$prefix}-rounded-modifier-radius-end-start: #{layout.$spacing-03};
  --#{$prefix}-rounded-modifier-radius-end-end: #{layout.$spacing-03};
}

// Add margin-block-end to input-after when not at max width and workspace is not showing
// Only apply when content-max-width is enabled (attribute present)
:host([content-max-width]:not([show-workspace]))
  .input-and-messages:not(.at-max-width)
  > .input-after {
  margin-block-end: 32px;
}

// 2. input gets corners only if input-after is empty
.shell.rounded
  .input-and-messages:not(.has-input-after-content)
  > .input.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
  border-end-start-radius: var(
    --#{$prefix}-rounded-modifier-radius-end-start,
    0
  );
}

// 3. input-before gets corners only if input-after and input are empty
.shell.rounded
  .input-and-messages:not(.has-input-after-content, .has-input-content)
  > .input-before.has-content {
  border-end-end-radius: var(--#{$prefix}-rounded-modifier-radius-end-end, 0);
  border-end-start-radius: var(
    --#{$prefix}-rounded-modifier-radius-end-start,
    0
  );
}

// When input-after has content, reset corners for all slots below it
.shell.rounded .input-and-messages.has-input-after-content {
  > .input,
  > .input-before {
    --#{$prefix}-rounded-modifier-radius-end-start: 0;
    --#{$prefix}-rounded-modifier-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// When input has content (and input-after is empty), reset corners for slots below it
.shell.rounded
  .input-and-messages:not(.has-input-after-content).has-input-content {
  > .input-before {
    --#{$prefix}-rounded-modifier-radius-end-start: 0;
    --#{$prefix}-rounded-modifier-radius-end-end: 0;

    border-end-end-radius: 0;
    border-end-start-radius: 0;
  }
}

// Made with Bob
